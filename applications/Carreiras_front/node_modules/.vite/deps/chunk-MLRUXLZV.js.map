{
  "version": 3,
  "sources": ["../../vuetify/src/composables/filter.ts"],
  "sourcesContent": ["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { computed, ref, unref, watchEffect } from 'vue'\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\n\n/**\n * - match without highlight\n * - single match (index), length already known\n * - single match (start, end)\n * - multiple matches (start, end), probably shouldn't overlap\n */\nexport type FilterMatch = boolean | number | [number, number] | [number, number][]\nexport type FilterFunction = (value: string, query: string, item?: InternalItem) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\nexport interface InternalItem<T = any> {\n  value: any\n  raw: T\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n\n  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase())\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\nexport function filterItems (\n  items: readonly (readonly [item: InternalItem, transformed: {}])[] | readonly InternalItem[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: { index: number, matches: Record<string, FilterMatch> }[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  loop:\n  for (let i = 0; i < items.length; i++) {\n    const [item, transformed = item] = wrapInArray(items[i]) as readonly [InternalItem, {}]\n    const customMatches: Record<string, FilterMatch> = {}\n    const defaultMatches: Record<string, FilterMatch> = {}\n    let match: FilterMatch = -1\n\n    if ((query || customFiltersLength > 0) && !options?.noFilter) {\n      if (typeof item === 'object') {\n        const filterKeys = keys || Object.keys(transformed)\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(transformed, key)\n          const keyFilter = options?.customKeyFilter?.[key]\n\n          match = keyFilter\n            ? keyFilter(value, query, item)\n            : filter(value, query, item)\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = match\n            else defaultMatches[key] = match\n          } else if (options?.filterMode === 'every') {\n            continue loop\n          }\n        }\n      } else {\n        match = filter(item, query, item)\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = match\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          !defaultMatchesLength\n        )\n      ) continue\n    }\n\n    array.push({ index: i, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter <T extends InternalItem> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query: Ref<string | undefined> | (() => string | undefined),\n  options?: {\n    transform?: (item: T) => {}\n    customKeyFilter?: MaybeRef<FilterKeyFunctions | undefined>\n  }\n) {\n  const filteredItems: Ref<T[]> = ref([])\n  const filteredMatches: Ref<Map<unknown, Record<string, FilterMatch>>> = ref(new Map())\n  const transformedItems = computed(() => (\n    options?.transform\n      ? unref(items).map(item => ([item, options.transform!(item)] as const))\n      : unref(items)\n  ))\n\n  watchEffect(() => {\n    const _query = typeof query === 'function' ? query() : unref(query)\n    const strQuery = (\n      typeof _query !== 'string' &&\n      typeof _query !== 'number'\n    ) ? '' : String(_query)\n\n    const results = filterItems(\n      transformedItems.value,\n      strQuery,\n      {\n        customKeyFilter: {\n          ...props.customKeyFilter,\n          ...unref(options?.customKeyFilter),\n        },\n        default: props.customFilter,\n        filterKeys: props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n\n    const originalItems = unref(items)\n\n    const _filteredItems: typeof filteredItems['value'] = []\n    const _filteredMatches: typeof filteredMatches['value'] = new Map()\n    results.forEach(({ index, matches }) => {\n      const item = originalItems[index]\n      _filteredItems.push(item)\n      _filteredMatches.set(item.value, matches)\n    })\n    filteredItems.value = _filteredItems\n    filteredMatches.value = _filteredMatches\n  })\n\n  function getMatches (item: T) {\n    return filteredMatches.value.get(item.value)\n  }\n\n  return { filteredItems, filteredMatches, getMatches }\n}\n"],
  "mappings": "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",
  "names": ["defaultFilter", "value", "query", "item", "toString", "toLocaleLowerCase", "indexOf", "makeFilterProps", "propsFactory", "customFilter", "Function", "customKeyFilter", "Object", "filterKeys", "Array", "String", "filterMode", "type", "default", "noFilter", "Boolean", "filterItems", "items", "options", "array", "filter", "keys", "wrapInArray", "customFiltersLength", "length", "loop", "i", "transformed", "customMatches", "defaultMatches", "match", "key", "getPropertyFromItem", "keyFilter", "title", "defaultMatchesLength", "customMatchesLength", "push", "index", "matches", "useFilter", "props", "filteredItems", "ref", "filteredMatches", "Map", "transformedItems", "computed", "transform", "unref", "map", "watchEffect", "_query", "strQuery", "results", "originalItems", "_filteredItems", "_filteredMatches", "forEach", "_ref", "set", "getMatches", "get"]
}
